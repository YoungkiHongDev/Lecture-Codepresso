# 자바 언어 탄생
91년 제임스 고슬링이 다양한 기기에서 동작하는 언어 개발을 목표로 그린 프로젝트를 진행했다.
95년 선 마이크로시스템즈에서 자바 1.0 버전을 공식으로 발표하였다.
현재까지도 계속 새로운 버전의 자바가 나오고 있다.

# 자바 언어 특징
1. WORA - Write Once Run Anywhere
Java 이전의 C언어 등은 하드웨어에 의존적이라 다른 하드웨어에서 쓰려면 재 컴파일 필요하다.
하지만 자바는 한번만 작성하고 컴파일하면 결과물이 어디서든 동작이 가능한데 이것은 JVM이 핵심 역할을 한다.

2. 객체 지향 언어
자바는 클래스를 기본 단위로 구성하여 상속, 다형성, 캡슐화 등 객체지향적 요소를 지원한다.

3. 자동화 된 메모리 관리
메모리 자원은 한정적이므로 효율적인 관리가 필수적이다.
C언어 같은 경우 메모리 관리를 개발자가 직접 해줘야 한다.
하지만 자바는 JVM의 Garbage Collector가 사용한 메모리 자원을 알아서 회수하므로 개발자가 신경 쓸 필요가 없다.

# 자바 언어 분야
안드로이드, 스프링, 하둡, 엘라스틱서치 등에서 사용된다.
모바일, 웹, 빅데이터, 데이터베이스, 데스크탑앱, 머신러닝, 게임, 임베디드 등 다양한 분야에서 쓸 수 있다.
하지만 가장 많이 쓰는 분야는 안드로이드, 스프링을 사용하는 모바일과 웹 분야이다.

# 소스코드의 실행 과정
1. 개발자가 소스코드 작성한다.
2. 컴파일 과정을 거친다.
3. 프로그램 결과물을 산출한다.
4. 하드웨어에서 실행시킨다.

# C언어의 컴파일
코드를 작성하고 컴파일한 결과물을 윈도우에서 실행할 수 있다면 리눅스에서는 실행할 수 없다.
리눅스에서 실행하기 위해서는 컴파일부터 리눅스 전용으로 다시 해야한다.

# Bytecode
자바 코드를 빌드하면 생성되는 중간코드로서 어셈블리어와 유사하다.

# JVM
자바 가상 머신으로 바이트코드를 실행한다.
WORA 구현의 핵심 역할을 하며, OS/HW 독립적으로 바이트코드를 실행할 수 있다.
따라서 JVM은 바이트코드와 OS/HW 사이의 번역기와 같은 역할을 한다.

# 자바 과정
자바 코드를 컴파일하면 결과물로 바이트코드가 산출된다.
이것을 JVM에서 윈도우/리눅스 어디서든 실행이 가능하다.
단, 운영체제에 맞는 JVM이 필요하다.

# JRE
JRE = JVM + 자바 애플리케이션을 실행하기위한 라이브러리

# JDK
JDK = JRE + 자바 개발 도구

# 실습 환경
JDK11
인텔리제이 커뮤니티 버전

# JDK 버전
JDK는 자바로 애플리케이션 개발을 위한 개발도구와 실행 환경을 포함한다.
현재 실무 환경에서는 JDK 8과 JDK 11 버전을 많이 사용한다.

# 자바 개발을 위한 IDE
1. 이클립스
2. 인텔리제이 (커뮤니티/얼티메이트)
3. VSCode

# JDK 설치
구글에 JDK 11 다운로드를 검색하여 오라클 사이트에서 설치한다.
이 때, 다운을 받으려면 오라클 계정이 필요하다.

# 자바 환경변수 세팅
jdk 설치 후 내PC 우클릭 속성에 들어간다.
시스템 창이 열리면 고급 시스템 설정에 들어간다.
시스템 속성 - 고급 - 환경변수에 들어간다.
시스템 변수 - 새로 만들기 - 새 시스템 변수에서 변수를 추가한다.
변수이름: JAVA_HOME
변수 값: JDK 설치 폴더 지정

시스템 변수 Path 안에 추가
-> %JAVA_HOME%\bin

제대로 설치되었나 확인하려면 CMD를 열어서 명령어를 입력한다.
-> java -version

# 인텔리제이 설치
구글에 인텔리제이 다운로드를 검색하여 제트브레인 사이트에서 설치한다.
커뮤니티 버전은 무료 버전으로 누구나 사용 가능하지만 기능이 제한적이다.
얼티메이트 버전은 학생이나 교사라면 인증하여 무료로 사용 가능하다.
얼티메이트 버전을 유료로 사용하려면 연간 149달러 지불해야한다.

# 클래스
자바 프로그램의 기본단위로 자바 프로그램은 한 개 이상의 클래스로 구성된다.
일반적으로 1개의 클래스는 1개의 자바 파일로 파일명과 클래스명이 동일하고 대문자로 시작한다.

# 객체
자바는 객체지향 언어로 객체는 사물이나 개념과 같다.
ex) 사물: 자동차 / 프린터 / 컴퓨터 / 자전거
ex) 개념: 옵션 / 강사 / 학생 / 게시물 / 회원

객체는 속성과 행동을 가진다.
ex) 자동차 객체
자동차 속성 (색상, 배기량, 가격, 모델명, 브랜드)
자동차 행동 (속도를 올린다, 속도를 줄인다, 방향을 바꾼다, 라디오를 켠다, 창문을 내린다)

ex) 강사 객체
강사 속성 (이름, 교과목, 나이, 학위, 성별)
강사 행동 (가르친다, 숙제를 낸다, 퀴즈를 출제한다, 시험을 채점한다, 상담을 한다)

# 클래스와 객체
클래스는 객체를 만들기 위한 틀 또는 템플릿을 말한다.
예를 들어 자동차 설계도가 클래스라면 양산된 자동차는 객체이다.

# 메인 메소드
자바 프로그램의 시작점이다.

# 블록
여러 라인의 코드를 중괄호로 묶은 단위이다.
클래스 블록과 메소드 블록 등이 있다.

# 세미콜론
실행 가능한 코드라인은 세미콜론으로 종료되어야 한다.
만약에 세미콜론이 생략 될 경우 에러가 발생한다.

# 들여쓰기
자바는 실행에 영향X (파이썬은 실행에 영향O)
없어도 무방하지만 코드의 가독성을 높이기 위해서는 반드시 필요하다.

인텔리제이에서 제공하는 자동 들여쓰기 기능
-> 상단 Code 메뉴에서 Reformat Code 클릭 또는 단축키로 Ctrl + Alt + L

# 표준 입출력
자바는 키보드 등으로부터 입력받고 모니터에 출력하기 위한 기본 라이브러리 제공한다.
예를 들어, System.out.println() 함수는 출력 및 줄바꿈을 수행한다.

# 자주 발생하는 문법 에러
1. 오타
2. 대소문자 에러 (자바는 기본적으로 대소문자를 구분함)
3. 세미콜론 생략

# 에러 상세정보 보기
인텔리제이는 하단의 Problems 탭에서 에러 상세 정보를 확인이 가능하다.

# 변수
데이터를 저장하기 위한 공간이다. 실제 데이터는 메모리에 저장된다. 명확한 이름으로 변수에 어떤 데이터가 들어가는지 쉽게 파악할 수 있게 하는 것이 중요하다.

# 변수의 선언
변수를 사용하기 위해 공간을 확보하는 것을 말한다. '=' 기호를 사용해 변수에 값을 저장한다.
ex) String name = "CodePresso";

# 변수 값의 사용
변수의 이름을 통해 변수에 저장되어 있는 값을 사용할 수 있다.

# 변수 작명 규칙 및 규약
Rule은 반드시 따라야 하고 Convention은 권장 사항이지만 이것을 지키면 품질과 가독성이 향상된다.

## Rule
- 변수 이름은 알파벳, 언더바_, 달러$ 로만 시작한다.
- 변수 이름은 대소문자를 구분한다.
- 자바에서 사용된 키워드는 변수 이름으로 사용이 불가하다. ex) if, ture, class, public
- 특수문자는 언더바_와 달러$만 사용이 가능하다.

## Convention
- 변수 이름은 최대한 의미있게 짓는다.
- 변수 이름은 알파벳 소문자로 시작한다.
- 여러 단어 연결 시 각 단어의 첫 글자를 대문자로 한다 (카멜식 표기법)

# 자료형
다양한 형태의 데이터를 종류에 따라 저장하기 위해 사용한다.

## 기본 자료형 Primitive Type
값 자체를 저장

## 참조 자료형 Reference Type
값에 접근하기 위한 참조 정보를 저장

## 자바 기본 자료형
자료형에 따라 크기가 다르고 표현 범위가 다르다.
- 정수형: byte, short, int, long
- 실수형: float, double
- 문자형: char
- 논리형: boolean

## 정수 자료형
자바 컴파일러는 숫자 값을 기본적으로 int형으로 판단한다.
정수 자료형의 경우 일반적인 웹 개발에서는 int와 long을 자주 사용한다.
int 범위를 넘는 숫자를 사용하기 위해서는 숫자 뒤에 'L' 접미사가 필요하다.
int형의 경우 숫자 범위가 약 21억이므로 그 이상 숫자 값을 long 타입을 쓰고 접미사로 L을 붙여준다.

## 실수 자료형
실수를 표현하는 자료형으로 float 타입은 'F' 접미사가 필요하다. 하지만 일반적으로 double을 많이 사용한다.

## 문자 자료형
하나의 문자를 저장할 수 있다. 작은 따옴표를 사용하여 값을 표현한다.

## 논리 자료형
참true 또는 거짓false을 저장하는 자료형이다.

## 문자열 자료형
String, 문자열 자료형으로 연속된 문자들의 집합을 저장한다. 큰 따옴표 사용하여 표현한다.

# 연산자
특정 작업을 수행하는 기호이다. 피연산자가 필요하고 연산의 결과가 존재한다.
- 대입 연산자: 값을 특정한 변수에 대입하기 위한 연산자
- 산술 연산자: 숫자 값을 대상으로 수학적 연산을 하기 위한 연산자
- 비교 연산자: 두 값을 비교하기 위한 연산자
- 논리 연산자: 조건들이 결합된 논리식의 결과를 판단하기 위한 연산자
- 비트 연산자: 비트 단위의 연산을 하기위한 연산자

## 비교 연산자
두 개의 피연산자를 비교한다. 결과는 true 혹은 false로 나오게 된다. 조건문이나 반복문에서 주로 사용된다. 문자열을 비교할 때에는 실제 객체끼리 비교하는 것이므로 비교 연산자가 아닌 equals() 메소드를 사용해야 객체를 비교할 수 있다.

## 연산자 우선순위
각 연산자는 우선순위가 존재한다. 연산이 복잡할 경우 괄호를 활용하여 원하는 순서를 명시해 줄 수 있다. 그렇게 한다면 연산 결과를 예상하기 쉽게 만들어 코드의 가독성이 향상된다.

# 형변환
특정 자료형 값을 다른 자료형으로 변환할 수 있다.

## 확장 형 변환
작은 크기에서 큰 크기로 형 변환하는 것으로 자동 형 변환을 할 수 있다.
- char와 Unicode: char는 실제 내부에서는 숫자로된 유니코드 값을 저장하고 있으므로 숫자로 형 변환이 가능하다.
- long과 float: long은 64비트, float은 32비트로 long이 더 크지만 표현 장식이 달라서 float이 더 큰 크기의 수를 표현 가능하므로 long을 float으로 형 변환이 가능하다.

## 축소 형 변환
큰 크기에서 작은 크기로 형 변환하는 것으로 개발자가 명시하여 명시적 형 변환이 가능하다. 데이터가 손실이 될 수 있어서 주의가 필요하다.
- Overflow와 Underflow: byte형의 표현 범위는 -128~127인데 이 범위를 넘어서는 -129 혹은 128을 형 변환하여 저장하려고 한다면 Overflow 혹은 Underflow가 발생하거나 양수와 음수가 바뀌는 것과 같이 예상치 못하는 문제가 발생할 수 있다.

# 제어문
## 조건문
조건에 따라 실행 코드 분기, 비교연산자 활용, 중괄호와 들여쓰기 사용
- 단일 if문: 조건식을 체크하고 참이면 if문 내부 코드 실행, 거짓이면 실행하지 않는다.
- if-else문: 조건식 결과에 따라 참이면 if문 내부 코드 실행, 거짓이면 else문 내부 코드를 실행한다.
- if-else if-else문: 조건식을 여러개 구성할 수 있는 조건문으로 조건이 맞는 해당 if문 혹은 else if문을 실행하거나 모두 거짓이면 else문을 실행한다.
- 논리 연산자: 둘 이상의 조건을 결합할 수 있는 연산자로 AND(&&), OR(||), NOT(!)의 3가지가 있다.
- 조건문 중첩: 조건문 안에 조건문을 사용하여 중첩한 형태로 코드의 가독성을 저하시키므로 복잡도를 낮추고 가독성을 높이기 위해 단순화와 다형성 활용을 고민할 필요가 있다.
- switch-case문: 경우의 수가 많은 조건식을 간결하게 표현하고 if-else if를 사용하는 것보다 빠른 조건문으로 switch의 값이 일치하는 case를 만나면 코드를 실행하거나 일치하는 case가 없다면 default를 실행하고 break로 빠져나간다.
- switch-case의 활용: break문은 생략 가능하며, case문 두개를 연달아 사용하여 OR 조건처럼 사용가능하다. (break 문을 생략하면 해당 케이스부터 default 까지 모두 실행)
- switch-case의 제한: switch 조건식의 결과는 정수 또는 문자열만 가능하며, case는 정수와 상수 그리고 문자열 상수만 가능하다. (예를들어 case에 변수 혹은 실수가 오면 에러 발생)

# 논리 연산자
둘 이상의 조건들을 결합하여 최종적으로 true 또는 false 값을 연산한다.
- AND (&&): 모든 조건이 true인 경우 결과가 true, 하나라도 false인 경우 결과가 false
- OR (||): 조건 중 하나라도 true인 경우 결과가 true, 모두 false인 경우 결과가 false
- NOT (!): 조건이 true인 경우 false, false인 경우 true로 반전시키는 연산

# 자료 구조
정수형, 문자형 등 하나의 변수에 1개의 데이터를 저장했지만 프로그램에서 사용되는 데이터는 복잡한 경우가 많다. 그래서 관련 있는 데이터를 그룹화하여 하나의 변수에 저장하고 처리하기 위해서 배열과 같은 자료 구조가 만들어졌다.

## 배열 Array
데이터를 담을 수 있는 상자가 연결된 형태로 단일 배열에는 동일한 자료형의 데이터만 저장이 가능하다. 배열 생성 시에 주어진 길이로 고정된다. 배열은 순서가 존재하여 배열의 각 칸에는 0부터 시작하여 길이-1 까지 인덱스가 매겨진다.

# 반복문
특정 코드 집합을 반복적으로 수행하는 것을 반복문이라고 한다. 주어진 조건을 만족할 때까지 반복하거나 일정 회수 만큼 반복한다.
- for: 특정 조건에 따라 코드를 반복하여 실행한다. 초기식, 조건식, 증감식으로 조건을 구분하여 조건이 true인 동안 내부 코드를 반복적으로 실행한다.
- Enhanced for: 배열 내 저장된 모든 값을 순차적으로 참조하기 위한 다른 형태의 for문이다. 기존의 for문은 변수 값을 실수하여 배열의 범위를 넘을 수 있는 위험성이 있지만 개선된 for문은 그러한 실수를 방지하며, 가독성도 더 좋아서 많이 사용된다.
- Nested for: for문 안에 또 다른 for문을 중첩하여 실행하는 형태로 중첩 횟수에는 제한이 없지만 가독성 및 복잡성을 고려할 필요가 있다.
- while: 반복문 구현을 위한 방법 주 ㅇ하나로 구조가 비교적 간결하다. for문과는 다르게 조건식 하나만 필요하며, 조건식 결과가 true인 동안 반복적으로 실행된다. 임베디드 시스템처럼 상태를 반복 체크하는 경우에는 for문보다 while문이 더 적합할 수 있다. 하지만 while문을 활용할 경우 의도치 않은 무한 루프가 발생할 가능성이 있는지 충분히 검토해야 한다.
- break: 반복문을 완전히 중단시키고 빠져나간다.
- continue: 반복문에서 현재 반복을 중단하고 다음 반복으로 넘어간다.

# SW 개발 방법론
SW는 매우 복잡하고 점점 거대해지고 있어서 요구사항대로 동작하는 SW를 정해진 기간과 예산대로 만드는 것이 어려워졌다. 그래서 큰 규모의 SW를 잘 만들고 관리할 수 있도록 SW 개발 방법론이 만들어졌다.

## SW 개발 방법론 순서
- 요구사항 수집
- 요구사항 분석
- 고수준 설계
- 상세 설계
- 구현
- 테스트

## SW 개발 방법론 종류
- 구조적 방법론
- 정보공학 방법론
- 객체지향 방법론
- 컴포넌트 기반 방법론
- 애자일 방법론

# 객체지향 프로그래밍
데이터와 데이터에 대한 연산을 수행하는 코드를 그룹화한 객체를 중심으로 SW를 설계/개발하는 패러다임이다. 시스템의 행위보다는 시스템에 참여하고 책임지는 객체가 무엇인지가 중요하다. 다수의 객체가 각자 역할을 하며, 객체 간 메시지를 주고 받으며 전체 시스템을 구성한다.

## 절차 지향 vs 객체 지향
- 절차 지향: 시스템의 행위에 집중
- 객체 지향: 시스템에 참여하는 요소들에 집중

## 객체지향 프로그래밍의 장점
- 복잡한 시스템을 역할과 책임에 따라 모듈화 가능
- SW 구성 요소 간의 더 명확한 커뮤니케이션이 가능
- SW를 좀 더 쉽게 유지보수가 가능

# 추상화
- 반드시 필요한 것들을 선택하고 불필요한 것들을 버리는 과정
- 객체지향의 추상화는 하나의 클래스를 설계하는 과정
- 특정 객체에 반드시 필요한 속성과 행위를 정의하는 과정

## 추상화 예제
ex) 이러닝 시스템의 관점에서 필요한 강사 클래스
- 속성(이름, 학위, 전공, 경력, 전문분야, 강의과목)
- 행위(강의하기, 숙제내기, 채점하기, 멘토링하기)

ex) 이러닝 시스템의 관점에서 필요한 사용자 클래스
- 속성(이름, 아이디, 비밀번호, 닉네임, 이메일)
- 행위(회원가입하기, 로그인하기, 강의수강하기, 강의구매하기, 회원정보조회하기)

# 클래스
클래스는 객체 생성을 위한 설계도이다. 어떤 속성과 행위를 포함할 것인지의 정보를 포함한다. class 키워드를 사용하여 표현하며, 멤버로 변수와 메소드를 포함한다.

## 좋은 클래스 설계
- 꼭 필요한 최소한의 속성과 행위만 존재한다.
- 속성과 행위 모두 특정 객체와 높은 관련성이 있어야 한다
- 너무 큰 규모의 클래스는 분할 될 필요가 있다.

## 클래스 명명 규칙
- 클래스명은 주로 명사로 작명
- 대문자로 시작하며, 단어가 연결될 경우 각 단어의 첫 문자를 대문자로 표시 ex) CoffeMaker
- 이름은 생성되는 객체를 가장 잘 표현한 의미있는 이름으로 작명

## 클래스 관련 문법
- 클래스명 변수명 = new 클래스명(); //객체를 생성하고 그 객체에 대한 참조 정보를 변수에 저장
- 객체참조변수명.멤버변수명 //점 연산자로 객체의 멤버 변수에 접근하여 값을 저장 혹은 사용

# 메소드
메소드는 객체의 행위를 정의한다.

## 메소드와 함수의 차이점
- 함수는 독립적으로 존재
- 함수는 특정 작업에 필요한 데이터를 모두 제공해야함
- 메소드는 특정 객체 내부에서 존재
- 메소드는 객체의 멤버 변수에 대한 연산이 가능

## 메소드 명명 규칙
- 메소드명은 행동을 표현하기 위해 보통 동사로 시작
- 첫 단어는 소문자로 시작하며, 2개 이상의 단어가 결합될 경우 연결 되는 단어의 첫 문자를 대문자로 표시 ex) getUserInfo()
- 메소드가 수행하는 작업을 의미있게 표현하는 이름으로 작명

# 캡슐화 (Encapsulation)
- 객체의 속성과 행동을 하나의 단위로 그룹화
- 객체의 속성과 행동을 은닉: 반드시 필요한 속성 및 행동만 외부에 노출, 대부분의 속성 및 행동은 외부에서 접근하지 못하도록 방지

## 객체의 정보 은닉
- 객체 내부에는 외부에서 접근해서 변경하면 안되는 속성이 존재한다. ex) 개인정보, 비밀번호
- 반드시 필요한 멤버만 외부에 노출하여 결합도를 줄일 수 있다.
- 외부에서 잘못된 형태로 속성을 변경하여 프로그램에 문제가 생기는 것을 막는다.
- 객체 간의 관계의 양(결합도)을 조정하여 좋은 설계를 만들 수 있다.

## 객체의 정보 은닉 목표
외부에서 모든 멤버에 접근할 수 있으면 결합도가 높아져 서로에 대해 영향이 너무커서 유지보수 역량이 낮아진다. 그래서 노출된 일부 멤버에만 외부에서 접근할 수 있게하여 멤버끼리 서로 호출하여 작업을 수행하여 외부 노출을 최소화 하는 것이 정보 은닉의 목표이다.

## 객체의 정보 은닉 방법
접근제어자를 활용하여 멤버의 접근을 제어한다.
1. public: 모든 곳에서 접근이 가능하다.
2. private: 외부에서 접근이 불가능하다.
3. protected: 상속 관계에서 자식이 부모 멤버에 접근이 가능하다.
4. default: 같은 패키지 내부에서만 접근이 가능하다. (접근 제어자를 명시하지 않으면 해당)

## private 접근 제어자 활용
- private으로 지정된 멤버는 외부에서 접근이 불가능
- private 멤버도 객체 내부에서는 접근이 가능
- 보통 모든 멤버 변수는 private으로 지정
- 외부에 반드시 노출이 필요한 메소드만 제외하고, 객체 내부에서만 활용되는 메소드도 private으로 지정

## private 멤버 변수 값 변경 및 사용
- 생성자로 객체 멤버 변수의 값을 초기화
- setter 메소드로 객체 멤버 변수의 값을 변경
- getter 메소드로 객체 멤버 변수의 값을 사용

# this 키워드
- 객체 내부에서 this는 해당 객체 자신을 의미한다.
- this.멤버변수A = 파라미터변수A; //객체의 멤버변수A에 변수명이 같은 파라미터변수A를 저장한다.
- 변수명이 다르면 this로 명시하지 않아도 무방하지만 파라미터 변수명을 의미있게 만들면 보통 중복된다.

# Setter 메소드
- private 멤버 변수의 값을 저장 혹은 변경하는 메소드이다.
- 값을 세팅하는 메소드로 set이라는 동사로 시작하여 메소드명을 짓는다.
- if-else문을 이용하여 적절하지 않는 값에 대비한 검증 로직 추가가 가능하다.

# 인자(argument) vs 파라미터(parameter)
- 인자: 인자는 메소드에 전달하는 데이터값 ex) 메소드 호출시 넣는 값 혹은 변수
- 파라미터: 전달받는 인자의 값을 저장하는 변수 ex) 메소드의 매개변수

# Getter 메소드
- private 멤버 변수의 값을 반환하는 메소드이다.
- 값을 반환하는 메소드로 get이라는 동사로 시작하여 메소드명을 짓는다.
- Getter는 파라미터가 없으므로 멤버 변수라고 따로 알려줄 필요가 없기에 this를 사용하지 않는다.

# 인텔리제이 Getter & Setter
인텔리제이 상단 메뉴의 Code -> Generate에서 Getter/Setter 메소드를 자동완성으로 만들 수 있다.

# 생성자 Constructor
- 생성자는 객체가 생성되는 시점에 호출되는 특별한 형태의 메소드
- 객체가 생성되는 시점에 초기화를 하기위해 사용
- 주로 생성자에서는 객체 멤버 변수의 초기화 작업을 함
- 멤버 변수를 명시적으로 초기화하지 않은 경우 숫자형 변수는 0, 불리안 변수는 false, 참조 변수는 null이 저장됨
- 생성자의 이름은 클래스의 이름과 동일
- 접근 제어자는 보통 public 사용
- 0개 또는 1개 이상의 파라미터 선언 가능
- 리턴 타입 생략 가능
- 생성자를 명시적으로 추가하지 않으면 Default 생성자가 제공됨 (new 키워드로 객체 생성 시 객체와 Default 생성자가 같이 만들어진다.)
- 파라미터가 있는 생성자를 호출하기 위해서는 new 키워드로 객체 생성 시 인자를 전달해야 호출 가능

# 메소드 오버로딩
- 메소드 오버로딩은 같은 클래스 내부에서 서로 다른 조합의 파라미터를 사용하는 동일한 이름의 메소드를 사용하는 것
- 파라미터의 자료형 또는 개수가 다르면 동일한 이름 사용가능
- 메소드 호출 시 파라미터 세팅에 따라 호출되는 메소드가 결정됨
- 리턴 타입만 다르고 파라미터가 같으면 오버로딩 불가능

## 메소드 오버로딩 예시
- public int add(int a, int b)
- public int add(int a, int b, int c)
- public double add(double a, double b)

# 생성자 오버로딩
- 생성자도 메소드이므로 오버로딩 가능
- 초기화를 원하는 멤버 변수만 선택해서 초기화 가능
- 생성자 오버로딩은 빈번하게 사용

# 상속
- 부모(Parent)/상위(Super)/기반(Base) 클래스
- 자식(Child)/하위(Sub)/파생(Derived) 클래스
- 일반화된 클래스(부모 클래스)를 재사용하여 새로운 구체적인 클래스(자식 클래스)를 생성하는 것을 상속이라고 한다.
- 자식 클래스는 부모 클래스의 모든 멤버변수와 메소드를 상속
- 상속을 거듭할수록 자식 클래스의 멤버 변수와 메소드 개수는 같거나 늘어남
- 상속의 횟수는 제한이 없음
- 객체지향 프로그래밍을 구성하는 주요 특징 중 하나
- 클래스 간 계층적 분류가 가능해짐
- 자바에서는 extends 키워드를 사용하여 상속
- 상속받은 멤버는 자식 클래스에서 별도로 선언하지 않음
- 상속받은 멤버에 대한 코드는 부모 클래스에서 공통적으로 관리가능

## 상속의 장점
- 코드의 재사용성 증가
- 클래스 간 계층 구조에 따른 다형성(polymorphism) 적용 가능

## 단일 상속
- 자바는 다중 상속을 허용하지 않음
- 하나의 클래스로부터만 상속을 받을 수 있음

## 인텔리제이 상속보기
왼쪽 아래 Structure 클릭 -> Structure 메뉴 중 공유 아이콘 모양 Show Inherited 클릭 -> 상속받은 멤버와 메소드 목록을 볼 수 있음

# 상속 관계의 접근 제어
- 외부로부터의 접근을 제한하기 위한 목적의 키워드
- 상속 관계에서의 접근을 제한하기 위해서도 사용됨
- 부모 클래스의 private 멤버 변수는 상속 받은 자식 클래스에서 접근이 제한됨
- 외부 접근이 필요할 경우 부모 클래스의 Getter나 Setter 메소드 제공이 필요함
- 부모 클래스의 protected 멤버는 자식 클래스에서 접근이 가능하다.

## 상속 관계의 접근 제어 활용
- 자식 클래스의 접근 제한은 private
- 자식 클래스의 접근 허용은 protected
- 모든 클래스의 접근 허용은 public

# 상속 관계의 생성자
- 부모 클래스의 생성자는 상속되지 않는다.
- 자식 클래스 객체 생성 시, 부모 클래스의 기본 생성자를 자동으로 호출한다.
- 최상위 부모 클래스의 생성자부터 자식 클래스의 생성자를 한 단계씩 아래의 자식으로 차례대로 호출한다.

# super 키워드
- super는 부모 클래스를 의미하는 키워드이다.
- super()는 부모 클래스의 파라미터 없는 생성자 호출한다.
- 자식 클래스에서 부모 클래스 생성자를 명시적으로 호출하지 않으면 Java 컴파일러가 자식 클래스 생성자의 첫 라인에 super()를 자동으로 삽입한다.
- 실제로는 최하위 클래스의 생성자가 먼저 호출되고 super()를 만나 한단계씩 올라가서 최상위 클래스의 생성자로 가서 실행을 마치고 한단계씩 실행시키면서 다시 최하위 클래스까지 내려온다.
- 부모 클래스의 생성자 뿐만 아니라 멤버 변수 또는 메소드에 접근 시에도 super를 사용한다.

# 메소드 오버라이딩
- 메소드 오버라이딩은 부모 클래스로부터 상속받은 메소드를 자식 클래스가 자신만의 특성에 맞게 새롭게 구현하는 것이다.

## 메소드 오버라이딩의 조건
- 오버라이딩하는 부모 클래스의 메소드와 이름이 같아야 한다.
- 오버라이딩하는 부모 클래스의 메소드와 파라미터가 같아야 한다.
- 오버라이딩하는 부모 클래스의 메소드와 리턴 타입이 같아야 한다.

# 자바 부모-자식 타입 호환
- 자바는 타입 간 호환에 매우 엄격한 언어이다.
- 기본적으로 서로 다른 타입의 객체를 참조할 수 없지만 예외인 경우가 있다.
- 바로 부모 타입의 참조 변수는 그 자식 타입의 객체를 참조가 가능한 것이다.
- [부모타입 변수 = new 자식타입();] 이와 같은 형식으로 자식의 객체를 참조할 수 있다.
- 부모 타입을 참조하는 변수와 자식 타입이 자기 자신을 참조하는 변수는 차이점이 있다.
- 후자의 변수를 통해서는 모든 멤버 변수와 메소드에 접근이 가능하다.
- 전자의 변수를 통해서는 자식만이 가지고 있는 멤버 변수나 메소드에 접근이 불가능하다.

# 다형성 Polymorphism
- 다형성은 객체지향의 주요 특성 중 하나이다.
- 다형성은 다양한 형태를 가질 수 있는 성질이다.
- 자바의 다형성은 특정 타입의 참조 변수가 때에 따라 다양한 객체를 참조 할 수 있다.
- 객체지향 설계원칙이나 디자인패턴에 굉장히 많이 적용이 되는 필수로 알아야하는 특성이다.
- 다형성은 리모콘으로 비유하자면 TV모드에서는 TV를, 에어컨 모드에서는 에어컨을, 라디오모드에서는 라디오를 동작시키는 것처럼 동일한 무언가가 때에 따라서 서로 다른 행동을 할 수 있는 것과 같다.
- 하나의 타입이 때에 따라 여러 종류의 객체의 특성을 가질 수 있는 것을 말한다.
- 어떤 객체를 참조하느냐에 따라서 다른 동작을 할 수 있다.
- 이것은 여러 종류의 객체를 참조할 수 있는 것과 같다.
- 같은 형태의 메소드가 때에 따라 다양한 동작을 수행한다.
- 자바에서는 2가지 특성을 이용하여 다형성을 구현한다.
- 1. 부모클래스의 참조 변수가 자식클래스의 객체를 참조가능
- 2. 메소드 오버라이딩

## 다형성을 사용하는 이유
- SW 요구사항 변경이나 추가에 대해 유연한 설계가 가능하다.
- 요구사항 변경 시 기존 코드의 수정을 최소화하고 확장 가능한 SW를 만들 수 있다.

## 다형성 실습
유저의 로그인을 관리하는 매니저 클래스를 만들었다. 유저는 관리자, 직원, 일반 등 다른 클래스로 분류된다. 그런데 그 유저의 객체를 매니저 클래스에 보내려면 객체의 타입이 다르므로 파라미터가 다른 메소드를 여러개 만들어야하는데 분류가 늘어나면 메소드가 늘어나고 같은 코드를 반복하게 된다. 이를 한번에 해결하기 위해서 부모타입의 대분류 클래스를 만들고 각 분류의 클래스에 상속시켜서 자식타입으로 만들어준다. 그리고 객체를 매니저 클래스의 메소드에 전달할 때는 부모타입 객체 변수에 자식타입을 참조시켜서 부모타입 변수를 파라미터로 받는 메소드 하나에만 전달하여 사용하면 된다. 이러한 방식으로 다형성을 써서 코드를 최소화시킬 수 있다.

# 패키지 package
- 패키지는 관련된 클래스를 묶어놓은 그룹이다.
- 클래스를 구분하는 일종의 디렉토리이다.
- 패키지는 하위 계층 구조를 가질 수 있다. (com.codepresso.newtube...)
- 하위 계층 구조는 점(.)을 통해 구분할 수 있다.
- 패키지의 이름과 구조는 실제 OS의 디렉토리 구조와 매핑된다. (패키지 생성 시 실제 디렉토리도 생성됨)

# 패키지 이름
- 패키지명은 소문자로만 작성하며, 클래스 묶음을 표현하는 의미있는 이름으로 작성한다.
- 패키지는 계층 구조를 가지며, 일반적으로 "1차도메인.회사명" 으로 시작된다.
- 패키지명 예시 -> com.회사명.프로젝트명.모듈명.서브모듈명
- 패키지명 예시 -> org.회사명(조직명).프로젝트명.모듈명.서브모듈명
- 패키지 명은 계층 구조 전체의 이름을 모두 포함한다.

# FQCN (Fully Qualified Class Name)
- 클래스의 FQCN은 패키지 명을 모두 포함한다.
- 패키지명 + 클래스명
- ex) User.java 파일 -> com.codepresso.newtube.user.User

# 패키지와 클래스
- 모든 클래스는 반드시 하나 이상의 패키지에 속한다.
- 클래스 생성시 패키지를 선언하지 않으면 이름이 없는 패키지인 unnamed package에 포함된다.
- 패키지를 선언하지 않은 모든 클래스는 모두 동일한 패키지에 속한다.

# 패키지 선언
- 해당 클래스가 어떤 패키지에 속하여 있다고 명시하는 것
- package 키워드를 통해 패키지명을 선언할 수 있다.
- 패키지 선언문은 .java 파일의 가장 첫 라인에 작성
- 모든 클래스에 단 한번만 패키지를 선언할 수 있다.

# 다른 패키지의 클래스 사용 import
- 다른 패키지에 속한 클래스 사용 시 클래스의 FQCN을 사용한다.
- FQCN의 반복을 피하려면 import문을 선언한다.
- 사용하고자 하는 클래스의 FQCN을 명시한다.
- 특정 패키지 내 모든 클래스를 사용하는 경우 FQCN 대신 "패키지명.*" 으로 특정 패키지내 모든 클래스를 사용가능하다.
- ex) import com.codepresso.newtube.user.User;
- ex) import com.codepresso.newtube.user.*;

# default 접근제어자
- 접근제어자를 명시하지 않으면 default 접근제어자가 적용된다.
- 같은 패키지 내에서는 접근이 가능하지만 다른 패키지에서는 접근이 불가능하다. (같은 패키지만 접근)
- 그 클래스를 상속 받았어도 패키지가 다를 경우 멤버 변수나 메소드가 default면 접근이 불가능하다.

# protected 접근제어자
- 같은 패키지 간에는 멤버에 접근이 가능하다.
- 상속 관계에서 부모 클래스의 패키지가 달라도 자식 클래스에서 부모 클래스의 멤버에 접근이 가능하다. (상속 관계가 아니면 불가능)

# 컬렉션 프레임워크
- 여러 건의 데이터를 다루기 위해서 Array 같은 자료구조 구현체가 필요하다.
- 다양한 특성을 가진 데이터를 다루기 위해서 그에 적합한 자료구조가 필요하다.
- 컬렉션 프레임워크는 다양한 자료구조 구현을 위한 클래스와 인터페이스의 집합이다.

# 컬렉션 프레임워크의 필요성
다양한 데이터를 위해서 자료구조의 구현체가 필요하며, 이를 클래스 라이브러리 형태로 제공한다.
- (ArrayList) 주식시장 데이터를 매분 마다 수집한다면 저장되는 데이터에 순서가 존재하고 중복을 허용해야 한다.
- (HashSet) 전 세계 모든 국가들의 이름을 GDP 순으로 저장한다면 저장되는 데이터에 순서가 존재하고 중복은 허용하지 않아야 한다.
- (HashMap) 한 사람의 개인 정보를 저장한다면 하나의 데이터를 설명하기 위한 여러 속성 정보가 필요하고 속성 간에는 순서가 필요없지만 동일한 속성으로 여러 개의 값이 존재할 수 없다.

자료구조에 저장된 데이터를 다루기 위해서 알고리즘 구현체가 필요하다. (데이터 조회, 삭제, 추가 등) 이것을 위해 자료구조 클래스에서 데이터를 가공하기 위한 메소드를 제공한다.
- ArrayList: add(), get(), size(), remove(), etc
- HashSet: add(), addAll(), size(), remove(), etc
- HashMap: put(), get(), remove(), etc

# 컬렉션 프레임워크 특징
- 데이터 개수의 동적인 변경 가능
- 객체만을 원소로 가진다. (Primitive Type까지 원소로 가지는 Array와 다르게 ArrayList는 Object 타입만 원소로 가진다. 하지만 Primitive Type의 값을 가진 레퍼런스 타입이 Object 형태로 저장되므로 Primitive Type 값을 저장하지 못하는 것은 아니다.)

# 컬렉션 프레임워크의 주요 인터페이스
- List/Set 인터페이스: Collection 인터페이스를 상속받아 정의하여 위치정보를 기억하고 순서대로 저장한다.
- Map 인터페이스: 키와 벨류로 저장하므로 구조상 차이로 Collection 인터페이스를 상속받지 않는다.

# 컬렉션 프레임워크 인터페이스들의 상속 관계
## java.util.Collection<E> 인터페이스 그룹
Iterable -> Collection -> List/Set

## java.util.Map<K,V> 인터페이스 그룹
구조상의 차이로 Collection 인터페이스를 상속받지 않고 독립적으로 정의

# 주요 인터페이스들의 특징
## java.util.List<E> 인터페이스 (ArrayList, LinkedList, Stack)
- 순서가 있는 데이터의 집합
- 데이터들의 중복을 허용

## java.util.Set<E> 인터페이스 (HashSet, TreeSet)
- 순서가 없는 데이터의 집합
- 데이터들의 중복을 허용하지 않음

## java.util.Map<K,V> 인터페이스 (HashMap, TreeMap)
- Key와 Value로 이루어진 페어를 갖는 데이터의 집합
- 데이터들 간의 순서가 없음
- Key는 중복을 허용하지 않지만, Value는 중복을 허용

# 제네릭
- 제네릭이란 데이터 타입을 일반화한다(generalize)는 것을 의미한다.
- 클래스나 메소드에서 사용할 데이터의 타입을 컴파일 시 타입을 체크하여 런타임 시 안정성이 보장된다.

# 제네릭 문법
## class ClassName<T> {}
- 제네릭을 사용한 클래스 정의 문법
- <T>: 클래스 내부에서 임의의 데이터 타입을 T라는 type variable로 지정한 것으로 T는 Type의 약어로 관행적으로 사용되는 이름이다. 원한다면 T가 아닌 다른 것으로 지정할 수도 있다.
## ClassName<Type-Class> object-name = new ClassName<>();
- 제네릭을 사용한 클래스 객체 생성 문법
- ClassName: 생성하고자 하는 Class 지정
- <Type-Class>: 클래스 정의 시 지정한 type variable에 사용할 실제 데이터 유형 Class이며, Primitive Type 데이터의 경우 Wrapper Class를 사용한다. (int -> Integer, double -> Double, etc)
- object-name: 변수명 지정

# 제네릭 장점
- 매개 변수의 범용성 확보: 클래스와 메소드를 정의하고 설계할 때 타입을 아직 모르겠거나 다양한 데이터 타입을 사용할 경우 활용할 수 있다. 클래스 내 임의의 변수를 매번 다른 데이터 타입으로 지정하여 객체 생성이 가능하다.
- 컴파일 시 타입 체크로 인한 런타임 안정성 확보: 범용성을 확보하면 타입이 고정되지 않아서 의도한 타입과 다를수도 있다. 하지만 제네릭을 사용하면 매개변수 값들의 타입체크를 먼저 수행하므로 안정성을 확보할 수 있다.
- 타입 변환 및 타입 검사에 들어가는 노력 절감: 타입 변환과 체크를 명시적으로 할 필요가 없다.

# ArrayList 개념
ArrayList는 Array와 가장 유사한 컬렉션 클래스이다. Array처럼 객체 내부의 데이터에 접근하기 위한 인덱스가 존재하지만 Array와는 다르게 생성된 객체에서 데이터의 추가와 삭제가 자유롭다.

# ArrayList 메소드
- add(데이터): 마지막 위치에 데이터를 추가하고 수행 결과를 참거짓으로 반환
- add(인덱스, 데이터): 해당 위치에 데이터를 추가하고 원래 있던 데이터는 한자리씩 뒤로 이동
- addAll(객체): 객체 내 모든 데이터 추가
- addAll(인덱스, 객체): 해당 위치부터 모든 데이터를 추가하고 원래 있던 데이터는 그 뒤로 이동
- get(인덱스): 해당 위치에 저장되어 있는 데이터를 반환
- indexOf(데이터): 해당 데이터가 저장되어 있는 인덱스 반환 (없으면 -1 반환)
- contains(데이터): 해당 데이터의 포함여부를 확인하고 수행 결과를 참거짓으로 반환
- size(): 저장되어 있는 데이터 개수 조회
- clear(): 객체 내 모든 데이터 제거
- remove(인덱스): 인덱스 위치의 데이터를 제거하고 해당 데이터 반환
- remove(데이터): 데이터를 객체에서 제거하고 수행 결과를 참거짓으로 반환
- removeAll(객체): 객체가 가진 데이터를 모두 제거하고 수행 결과를 참거짓으로 반환
- set(인덱스, 데이터): 인덱스 위치에 데이터를 삽입하고 원래 있던 데이터는 반환
- Collections.sort(리스트): 리스트를 오름차순으로 정렬
- Collections.reverse(리스트): 리스트를 내림차순으로 정렬
- Arrays.asList(Array 또는 값나열): Array 객체를 이용하여 ArrayList 객체를 생성

# HashMap 개념
HashMap은 파이썬의 Dictionary와 유사한 컬렉션 클래스이다. 키값이 해시 알고리즘을 이용하여 구조화되어 있어 키값을 이용한 검색 속도가 빠르다.

# HashMap 메소드
- put(키, 벨류): 객체 생성 시 지정한 테이터 타입의 키-벨류 페어를 추가, 키-벨류 null값 허용, 이미 등록된 키라면 벨류를 업데이트하고 기존의 벨류를 반환
- putAll(Map객체): Map 객체의 모든 페어 데이터를 추가
- get(키): 키에 매핑된 벨류 반환
- getOrDefault(키, 디폴트값): 키가 존재하지 않는 키라면 디폴트값 반환
- containsKey(키): 키가 객체에 존재하는지 확인 후 수행 결과를 참거짓으로 반환
- containsValue(벨류): 벨류가 객체에 존재하는지 확인 후 수행 결과를 참거짓으로 반환 
- values(): 객체에 존재하는 모든 벨류를 Collection 객체 형태로 반환
- keySet(): 객체에 존재하는 모든 키를 Set 객체 형태로 반환
- size(): 객체에 존재하는 모든 페어 데이터의 개수를 조회
- clear(): 객체 내 모든 데이터 제거
- remove(키): 키의 데이터 페어를 제거하고 해당 페어의 벨류를 반환
- remove(키, 벨류): 키와 벨류가 모두 일치하는 데이터 페어를 제거하고 수행 결과를 참거짓으로 반환

# HashSet 개념
List처럼 여러 데이터를 하나의 객체로 관리한다. List의 인덱스와 Map의 Key처럼 데이터에 접근하기 위한 정보가 없다. 저장된 데이터가 Hash 알고리즘을 이용해 구조화되어 있어 데이터 탐색 속도가 빠르다. 중복을 허용하지 않는다.

# HashSet 메소드
- add(데이터): 데이터를 순서없이 추가하고 수행 결과로 참거짓을 반환, 중복 데이터는 추가 불가능
- addAll(Collection객체); Collection 객체의 데이터들을 추가, 중복 데이터는 제거하고 추가하는 합집합과 동일한 기능 수행
- contatins(데이터): 데이터의 객체 포함여부를 확인하여 수행 결과를 참거짓으로 반환
- hashCode(): HashSet 객체 내 데이터들의 Hash 값을 모두 더한 값을 반환, Null값은 0으로 Hashing, HashSet 객체들이 동일한 지 체크할 때 사용가능
- size(): 객체에 저장되어 있는 데이터의 개수 조회
- clear(): 객체 내 모든 데이터 제거
- remove(데이터): 데이터를 객체에서 제거하고 수행 결과를 참거짓으로 반환
- removeAll(Collection객체): Collection 객체가 가진 데이터와 같은 데이터들을 모두 제거, 차집합과 동일한 기능 수행 
- retainAll(Collection객체): 두개의 HashSet 객체에 모두 존재하는 데이터만 선택하여 남김, 교집합과 동일한 기능 수행